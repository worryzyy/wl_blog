[[toc]]

## 浏览器相关！！

### 这里先抛出一个问题：浏览器地址栏输入 URL 后按回车发生了什么？

#### 1.网络

浏览器网络线程接收到 HTML 文档后，产生一个渲染任务，将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程

#### 2.渲染

渲染流程分为：
HTML 解析：先遇到哪个就解析哪个（CSS、Js），解析前会有一个预解析，先下载外部的 CSS 和 Js 文件。
如果外部的 CSS 没有下载解析好，主线程不会等待，会继续解析后面的 HTML，下载和解析 CSS 都是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。

如果主线程解析到 script 位置，会停止解析 HTML，要等待 JS 文件下载好，将全局代码解析执行完毕才会继续解析 HTML，因为 JS 代码执行过程有可能修改当前的 dom 树，所以 dom 树的生成必须暂停，这就是为什么 JS 会阻塞 HTML 解析的根本原因。

样式计算、布局、分层、绘制、分块、光模块、画

### 事件循环

事件循环又叫消息循环，是浏览器渲染主线程的工作方式。
主线程在遇到一些不能立即执行的任务时，会将任务放入其他线程，合适的时候将任务加入到消息队列的末尾，等主线程执行完毕再调度执行
每个任务都有不同的类型：大致是 微队列（Promise）、定时器、交互队列，消息队列没有优先级，先进先出，但是任务队列类型有优先级，微队列的优先级最高

#### 怎么理解 Js 的异步

由于 Js 是一门单线程语言，它运行在浏览器的渲染主线程上，而渲染主线程只有一个；如果使用同步方式，有可能会造成主线程阻塞，所以采用异步的方式，当某些任务执行时，主线程会将他们交给其他线程，再执行后续代码。当其他线程完成时，将传递的回调函数包装成任务，加入到消息队列末尾排队，等待主线程的调度执行。在这种异步模式下，浏览器永不阻塞，保证了单线程的流畅运行

====

单线程导致异步的出现

事件循环是异步的实现方式

## 一些八股文！！

### 闭包

能够读取其他函数内部变量的函数

```js
function fn() {
  var n = 999
  function fn1() {
    console.log(n)
  }
  return fn1
}
var result = fn1()
result() //999
```

函数 fn1 就是闭包，闭包的好处在于：

1. 可以读取函数内部变量

2.让变量的值保存在内存中

针对第二点：

```js
function f1() {
  var n = 999
  nAdd = function () {
    n += 1
  }
  function f2() {
    alert(n)
  }
  return f2
}
var result = f1()
result() // 999
nAdd()
result() // 1000
```

可以看到函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除
